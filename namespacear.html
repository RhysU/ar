<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>github.com/RhysU/ar: ar Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">github.com/RhysU/ar
   </div>
   <div id="projectbrief">Autoregressive process modeling tools in header-only C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">ar Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Autoregressive process modeling tools in header-only C++.  
<a href="namespacear.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1AIC.html">AIC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the Akaike information criterion (<a class="el" href="structar_1_1AIC.html" title="Represents the Akaike information criterion (AIC).">AIC</a>).  <a href="structar_1_1AIC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1AICC.html">AICC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the asymptotically-corrected Akaike information criterion (<a class="el" href="structar_1_1AICC.html" title="Represents the asymptotically-corrected Akaike information criterion (AICC).">AICC</a>).  <a href="structar_1_1AICC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1best__model__function.html">best_model_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template typedef and helper method returning a <a class="el" href="namespacear.html#adf03e3dd501f7a75d42655908b748ba2">best_model</a> implementation matching a model selection criterion provided at runtime.  <a href="structar_1_1best__model__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1BIC.html">BIC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the consistent criterion <a class="el" href="structar_1_1BIC.html" title="Represents the consistent criterion BIC.">BIC</a>.  <a href="structar_1_1BIC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1Burg.html">Burg</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents estimation using Burg's recursive method.  <a href="classar_1_1Burg.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1CIC.html">CIC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the combined information criterion (<a class="el" href="structar_1_1CIC.html" title="Represents the combined information criterion (CIC) as applied to a particular estimation_method.">CIC</a>) as applied to a particular <a class="el" href="structar_1_1estimation__method.html">estimation_method</a>.  <a href="structar_1_1CIC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1criterion.html">criterion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Criteria for autoregressive model order selection following Broersen.  <a href="structar_1_1criterion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1empirical__variance__function.html">empirical_variance_function</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL-ready binary_function for a given method's empirical variance.  <a href="structar_1_1empirical__variance__function.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1empirical__variance__generator.html">empirical_variance_generator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL AdaptableGenerator for a given method's empirical variance.  <a href="classar_1_1empirical__variance__generator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1empirical__variance__iterator.html">empirical_variance_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An immutable RandomAccessIterator over a method's empirical variance sequence.  <a href="classar_1_1empirical__variance__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1estimation__method.html">estimation_method</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parent type for autoregressive process parameter estimation techniques.  <a href="structar_1_1estimation__method.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1FIC.html">FIC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the finite information criterion (<a class="el" href="structar_1_1FIC.html" title="Represents the finite information criterion (FIC) as applied to a particular estimation_method.">FIC</a>) as applied to a particular <a class="el" href="structar_1_1estimation__method.html">estimation_method</a>.  <a href="structar_1_1FIC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1FIC_3_01YuleWalker_3_01MeanHandling_01_4_00_01AlphaNumerator_00_01AlphaDenominator_01_4.html">FIC&lt; YuleWalker&lt; MeanHandling &gt;, AlphaNumerator, AlphaDenominator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the finite information criterion (<a class="el" href="structar_1_1FIC.html" title="Represents the finite information criterion (FIC) as applied to a particular estimation_method.">FIC</a>) as applied to the <a class="el" href="classar_1_1YuleWalker.html">YuleWalker</a> <a class="el" href="structar_1_1estimation__method.html">estimation_method</a>.  <a href="structar_1_1FIC_3_01YuleWalker_3_01MeanHandling_01_4_00_01AlphaNumerator_00_01AlphaDenominator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1FSIC.html">FSIC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the finite sample information criterion (<a class="el" href="structar_1_1FSIC.html" title="Represents the finite sample information criterion (FSIC) as applied to a particular estimation_metho...">FSIC</a>) as applied to a particular <a class="el" href="structar_1_1estimation__method.html">estimation_method</a>.  <a href="structar_1_1FSIC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1GIC.html">GIC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the generalized information criterion (<a class="el" href="structar_1_1GIC.html" title="Represents the generalized information criterion (GIC).">GIC</a>).  <a href="structar_1_1GIC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1LSF.html">LSF</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents forward prediction least squares minimization.  <a href="classar_1_1LSF.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1LSFB.html">LSFB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents forward and backward prediction least squares minimization.  <a href="classar_1_1LSFB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1MCC.html">MCC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the minimally consistent criterion (<a class="el" href="structar_1_1MCC.html" title="Represents the minimally consistent criterion (MCC).">MCC</a>).  <a href="structar_1_1MCC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1mean__retained.html">mean_retained</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Denotes the sample mean was retained in a signal during estimation.  <a href="structar_1_1mean__retained.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structar_1_1mean__subtracted.html">mean_subtracted</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method-specific estimation variance routines following Broersen.  <a href="structar_1_1mean__subtracted.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1predictor.html">predictor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simulate an autoregressive model process with an InputIterator interface.  <a href="classar_1_1predictor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1strided__adaptor.html">strided_adaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An adapter to add striding over another (usually random access) iterator.  <a href="classar_1_1strided__adaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classar_1_1YuleWalker.html">YuleWalker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents estimation by solving the Yule&ndash;Walker equations.  <a href="classar_1_1YuleWalker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Autoregressive process modeling tools in header-only C++. </p>
<p>All routines estimate and/or evaluate autoregressive models of the form </p><p class="formulaDsp">
\begin{align} x_n + a_1 x_{n - 1} + \dots + a_p x_{n - p} &amp;= \epsilon_n &amp; \epsilon_n &amp;\sim{} N\left(0, \sigma^2_\epsilon\right) \\ \sigma^2_x \left( \rho_0 + a_1 \rho_{1} + \dots + a_p \rho_{p} \right) &amp;= \sigma^2_\epsilon &amp; \rho_0 &amp;= 1 \\ \rho_k + a_1 \rho_{k-1} + \dots + a_p \rho_{k-p} &amp;= 0 &amp; k &amp;\geq{} p \end{align}
</p>
<p> where \(x_i\) are the process values, \(a_i\) are the model parameters, and \(\rho_i\) are the lag \(i\) autocorrelations. The white noise input process \(\epsilon_n\) has variance \(\sigma^2_\epsilon\). The model has output variance \(\sigma^2_x\) and therefore a gain equal to \(\sigma^2_x / \sigma^2_\epsilon\). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a7a5016706d3db6d6b5d8c8cf9939dcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5016706d3db6d6b5d8c8cf9939dcfb">&#9670;&nbsp;</a></span>autocorrelation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator , class InputIterator , class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classar_1_1predictor.html">predictor</a>&lt;typename std::iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt; ar::autocorrelation </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>params_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>params_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>autocor_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an iterator over the autocorrelation function \(\rho_k\) given process parameters and initial conditions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params_first</td><td>Beginning of range containing \(a_1,\dots,a_p\). </td></tr>
    <tr><td class="paramname">params_last</td><td>Exclusive ending of the parameter range. </td></tr>
    <tr><td class="paramname">gain</td><td>The model gain \(\sigma^2_x / \sigma^2_\epsilon\). </td></tr>
    <tr><td class="paramname">autocor_first</td><td>Beginning of range containing \(\rho_0,...\rho_p\).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An InputIterator across the autocorrelation function starting with \(\rho_0\). </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l01087">1087</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a id="ad25b398513a5759801f27dd6361b87fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25b398513a5759801f27dd6361b87fc">&#9670;&nbsp;</a></span>best_model() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer1 , typename Integer2 , class Sequence1 , class Sequence2 , class Sequence3 , class Sequence4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Sequence1::difference_type ar::best_model </td>
          <td>(</td>
          <td class="paramtype">Integer1&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer2&#160;</td>
          <td class="paramname"><em>minorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence1 &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence2 &amp;&#160;</td>
          <td class="paramname"><em>sigma2e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence3 &amp;&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence4 &amp;&#160;</td>
          <td class="paramname"><em>autocor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the best model according to <a class="el" href="structar_1_1criterion.html">criterion</a> applied to \(\sigma^2_\epsilon\) given a hierarchy of candidates. </p>
<p>On input, <code>params</code>, <code>sigma2e</code>, <code>gain</code>, and <code>autocor</code> should be <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a>s which were populated by <a class="el" href="namespacear.html#a670daa7e96d698681f914427999105fd">burg_method</a> when <code>hierarchy</code> is <code>true</code> (or in some other equivalent manner). On output, these arguments will contain only values relevant to the best model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). For example, the return value of <a class="el" href="namespacear.html#a670daa7e96d698681f914427999105fd">burg_method</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minorder</td><td>Constrain the best model to be at least this order. Supplying zero specifies no constraint. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">params</td><td>Model parameters </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sigma2e</td><td>\(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gain</td><td>Model gain </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">autocor</td><td>Model autocorrelations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the best model within the inputs.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>best_model(Integer1,Integer2,Sequence1,Sequence2,Sequence3,Sequence4,OutputIterator) </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l02466">2466</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a id="adf03e3dd501f7a75d42655908b748ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf03e3dd501f7a75d42655908b748ba2">&#9670;&nbsp;</a></span>best_model() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer1 , typename Integer2 , class Sequence1 , class Sequence2 , class Sequence3 , class Sequence4 , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Sequence1::difference_type ar::best_model </td>
          <td>(</td>
          <td class="paramtype">Integer1&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer2&#160;</td>
          <td class="paramname"><em>minorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence1 &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence2 &amp;&#160;</td>
          <td class="paramname"><em>sigma2e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence3 &amp;&#160;</td>
          <td class="paramname"><em>gain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sequence4 &amp;&#160;</td>
          <td class="paramname"><em>autocor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>crit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Obtain the best model according to <a class="el" href="structar_1_1criterion.html">criterion</a> applied to \(\sigma^2_\epsilon\) given a hierarchy of candidates. </p>
<p>On input, <code>params</code>, <code>sigma2e</code>, <code>gain</code>, and <code>autocor</code> should be <a href="http://www.sgi.com/tech/stl/Sequence.html">Sequence</a>s which were populated by <a class="el" href="namespacear.html#a670daa7e96d698681f914427999105fd">burg_method</a> when <code>hierarchy</code> is <code>true</code> (or in some other equivalent manner). On output, these arguments will contain only values relevant to the best model.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). For example, the return value of <a class="el" href="namespacear.html#a670daa7e96d698681f914427999105fd">burg_method</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minorder</td><td>Constrain the best model to be at least this order. Supplying zero specifies no constraint. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">params</td><td>Model parameters </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">sigma2e</td><td>\(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">gain</td><td>Model gain </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">autocor</td><td>Model autocorrelations </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">crit</td><td>Value assigned to each model by the criterion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the best criterion value within <code>crit</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l02310">2310</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p class="reference">References <a class="el" href="ar_8hpp_source.html#l00134">AR_ENSURE_ARG</a>.</p>

</div>
</div>
<a id="a670daa7e96d698681f914427999105fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670daa7e96d698681f914427999105fd">&#9670;&nbsp;</a></span>burg_method() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Value , class OutputIterator1 , class OutputIterator2 , class OutputIterator3 , class OutputIterator4 , class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::burg_method </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>data_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>data_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>maxorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>params_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>sigma2e_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator3&#160;</td>
          <td class="paramname"><em>gain_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator4&#160;</td>
          <td class="paramname"><em>autocor_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>subtract_mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hierarchy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>Ak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>ac</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit an autoregressive model to stationary time series data using Burg's method. </p>
<p>That is, find coefficients \(a_i\) such that the sum of the squared errors in the forward predictions \(x_n = -a_1 x_{n-1} - \dots - a_p x_{n-p}\) and backward predictions \(x_n = -a_1 x_{n+1} - \dots - a_p x_{n+p}\) are both minimized. Either a single model of given order or a hierarchy of models up to and including a maximum order may fit.</p>
<p>The input data \(\vec{x}\) are read from <code>[data_first, data_last)</code> in a single pass. The mean is computed, returned in <code>mean</code>, and <em>removed</em> from further consideration whenever <code>subtract_mean</code> is true. The estimated model parameters \(a_i\) are output using <code>params_first</code> with the behavior determined by the amount of data read, <code>maxorder</code>, and the <code>hierarchy</code> flag: </p><ul>
<li>
If <code>hierarchy</code> is <code>false</code>, only the \(a_1, \dots, a_\text{maxorder}\) parameters for an AR(<code>maxorder</code>) process are output. </li>
<li>
If <code>hierarchy</code> is <code>true</code>, the <code>maxorder*(maxorder+1)/2</code> parameters \(a_1, \dots, a_m\) for models AR(0), AR(1), AR(2), ..., AR(maxorder) are output. Notice AR(0) has no parameters.  </li>
</ul>
<p>Note that the latter case is <em>always</em> computed; the <code>hierarchy</code> flag merely controls what is output. In both cases, the maximum order is limited by the number of data samples provided and is output to <code>maxorder</code>.</p>
<p>One mean squared discrepancy \(\sigma^2_\epsilon\), also called the innovation variance, and gain, defined as \(\sigma^2_x / \sigma^2_\epsilon\), are output for each model, including the trivial zeroth order model when <code>maxorder</code> is zero or <code>hierarchy</code> is <code>true</code>, using <code>sigma2e_first</code> and <code>gain_first</code>. The autocorrelations for lags <code>[0,k]</code> are output using <code>autocor_first</code>. When <code>hierarchy</code> is <code>true</code>, only lags <code>[0,m]</code> should be applied for some AR(<code>m</code>) model. Outputting the lag <code>k</code> autocorrelation is technically redundant as it may be computed from \(a_i\) and lags <code>0, ..., k-1</code>. Autocovariances may be computed by multiplying the autocorrelations by the gain times \(\sigma^2_\epsilon\).</p>
<p>The software aspects of the implementation differs from many other sources. In particular, </p><ul>
<li>
iterators are employed, </li>
<li>
the working precision is selectable using <code>mean</code>, </li>
<li>
the mean squared discrepancy calculation has been added, </li>
<li>
some loop index transformations have been performed, </li>
<li>
working storage may be passed into the method to reduce allocations across many invocations (see overload with Vector parameters), and </li>
<li>
and all lower order models may be output during the recursion using <code>hierarchy</code>. </li>
</ul>
<p>Gain and autocorrelation calculations have been added based on sections 5.2 and 5.3 of Broersen, P. M. T. Automatic autocorrelation and spectral analysis. Springer, 2006. <a href="http://dx.doi.org/10.1007/1-84628-329-9">http://dx.doi.org/10.1007/1-84628-329-9</a>. The classical algorithm, rather than the variant using denominator recursion due to Andersen (<a href="http://dx.doi.org/10.1109/PROC.1978.11160">http://dx.doi.org/10.1109/PROC.1978.11160</a>), has been chosen as the latter can be numerically unstable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>Mean of data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">maxorder</td><td>On input, the maximum model order desired. On output, the maximum model order computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">params_first</td><td>Model parameters for a single model or for an entire hierarchy of models. At most <code>!hierarchy ? maxorder : maxorder*(maxorder+1)/2</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sigma2e_first</td><td>The mean squared discrepancy for only AR(<code>maxorder</code>) or for an entire hierarchy. Either one or at most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gain_first</td><td>The model gain for only AR(<code>maxorder</code>) or an entire hierarchy. Either one or at most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">autocor_first</td><td>Lag one through lag maxorder autocorrelations. At most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subtract_mean</td><td>Should <code>mean</code> be subtracted from the data? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hierarchy</td><td>Should the entire hierarchy of estimated models be output?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number data values processed within <code>[data_first, data_last)</code>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>Working storage. Reuse across invocations may speed execution by avoiding allocations. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Working storage similar to <code>f</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">Ak</td><td>Working storage similar to <code>f</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ac</td><td>Working storage similar to <code>f</code>. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l00542">542</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p class="reference">References <a class="el" href="ar_8hpp_source.html#l00217">welford_variance_population()</a>.</p>

</div>
</div>
<a id="a430964ca6f3d8fc2b6a00416bf4b3ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430964ca6f3d8fc2b6a00416bf4b3ab5">&#9670;&nbsp;</a></span>burg_method() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class Value , class OutputIterator1 , class OutputIterator2 , class OutputIterator3 , class OutputIterator4 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::burg_method </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>data_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>data_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>maxorder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator1&#160;</td>
          <td class="paramname"><em>params_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator2&#160;</td>
          <td class="paramname"><em>sigma2e_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator3&#160;</td>
          <td class="paramname"><em>gain_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator4&#160;</td>
          <td class="paramname"><em>autocor_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>subtract_mean</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hierarchy</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fit an autoregressive model to stationary time series data using Burg's method. </p>
<p>That is, find coefficients \(a_i\) such that the sum of the squared errors in the forward predictions \(x_n = -a_1 x_{n-1} - \dots - a_p x_{n-p}\) and backward predictions \(x_n = -a_1 x_{n+1} - \dots - a_p x_{n+p}\) are both minimized. Either a single model of given order or a hierarchy of models up to and including a maximum order may fit.</p>
<p>The input data \(\vec{x}\) are read from <code>[data_first, data_last)</code> in a single pass. The mean is computed, returned in <code>mean</code>, and <em>removed</em> from further consideration whenever <code>subtract_mean</code> is true. The estimated model parameters \(a_i\) are output using <code>params_first</code> with the behavior determined by the amount of data read, <code>maxorder</code>, and the <code>hierarchy</code> flag: </p><ul>
<li>
If <code>hierarchy</code> is <code>false</code>, only the \(a_1, \dots, a_\text{maxorder}\) parameters for an AR(<code>maxorder</code>) process are output. </li>
<li>
If <code>hierarchy</code> is <code>true</code>, the <code>maxorder*(maxorder+1)/2</code> parameters \(a_1, \dots, a_m\) for models AR(0), AR(1), AR(2), ..., AR(maxorder) are output. Notice AR(0) has no parameters.  </li>
</ul>
<p>Note that the latter case is <em>always</em> computed; the <code>hierarchy</code> flag merely controls what is output. In both cases, the maximum order is limited by the number of data samples provided and is output to <code>maxorder</code>.</p>
<p>One mean squared discrepancy \(\sigma^2_\epsilon\), also called the innovation variance, and gain, defined as \(\sigma^2_x / \sigma^2_\epsilon\), are output for each model, including the trivial zeroth order model when <code>maxorder</code> is zero or <code>hierarchy</code> is <code>true</code>, using <code>sigma2e_first</code> and <code>gain_first</code>. The autocorrelations for lags <code>[0,k]</code> are output using <code>autocor_first</code>. When <code>hierarchy</code> is <code>true</code>, only lags <code>[0,m]</code> should be applied for some AR(<code>m</code>) model. Outputting the lag <code>k</code> autocorrelation is technically redundant as it may be computed from \(a_i\) and lags <code>0, ..., k-1</code>. Autocovariances may be computed by multiplying the autocorrelations by the gain times \(\sigma^2_\epsilon\).</p>
<p>The software aspects of the implementation differs from many other sources. In particular, </p><ul>
<li>
iterators are employed, </li>
<li>
the working precision is selectable using <code>mean</code>, </li>
<li>
the mean squared discrepancy calculation has been added, </li>
<li>
some loop index transformations have been performed, </li>
<li>
working storage may be passed into the method to reduce allocations across many invocations (see overload with Vector parameters), and </li>
<li>
and all lower order models may be output during the recursion using <code>hierarchy</code>. </li>
</ul>
<p>Gain and autocorrelation calculations have been added based on sections 5.2 and 5.3 of Broersen, P. M. T. Automatic autocorrelation and spectral analysis. Springer, 2006. <a href="http://dx.doi.org/10.1007/1-84628-329-9">http://dx.doi.org/10.1007/1-84628-329-9</a>. The classical algorithm, rather than the variant using denominator recursion due to Andersen (<a href="http://dx.doi.org/10.1109/PROC.1978.11160">http://dx.doi.org/10.1109/PROC.1978.11160</a>), has been chosen as the latter can be numerically unstable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data_first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data_last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>Mean of data. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">maxorder</td><td>On input, the maximum model order desired. On output, the maximum model order computed. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">params_first</td><td>Model parameters for a single model or for an entire hierarchy of models. At most <code>!hierarchy ? maxorder : maxorder*(maxorder+1)/2</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sigma2e_first</td><td>The mean squared discrepancy for only AR(<code>maxorder</code>) or for an entire hierarchy. Either one or at most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gain_first</td><td>The model gain for only AR(<code>maxorder</code>) or an entire hierarchy. Either one or at most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">autocor_first</td><td>Lag one through lag maxorder autocorrelations. At most <code>maxorder + 1</code> values will be output. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subtract_mean</td><td>Should <code>mean</code> be subtracted from the data? </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hierarchy</td><td>Should the entire hierarchy of estimated models be output?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number data values processed within <code>[data_first, data_last)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l00752">752</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p class="reference">References <a class="el" href="ar_8hpp_source.html#l00542">burg_method()</a>.</p>

</div>
</div>
<a id="a384a8192b7c66d6f0d8a06c4c26ef227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384a8192b7c66d6f0d8a06c4c26ef227">&#9670;&nbsp;</a></span>decorrelation_time() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value ar::decorrelation_time </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classar_1_1predictor.html">predictor</a>&lt; Value &gt;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>abs_rho</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the decorrelation time for variance of the mean given autocorrelation details. </p>
<p>That is, compute </p><p class="formulaDsp">
\begin{align} T_0 &amp;= 1 + 2 \sum_{i=1}^{N} \left(1 - \frac{i}{N}\right) \rho_i \end{align}
</p>
<p> following Trenberth, K. E. "Some effects of finite sample size and
persistence on meteorological statistics. Part I: Autocorrelations." Monthly Weather Review 112 (1984). <a href="http://dx.doi.org/10.1175/1520-0493(1984)112%3C2359:SEOFSS%3E2.0.CO;2">http://dx.doi.org/10.1175/1520-0493(1984)112%3C2359:SEOFSS%3E2.0.CO;2</a></p>
<p>Rather than \(\rho\), \(\left|\rho\right|\) may be used in the definition of \(T_0\) to better approximate the "decay of the correlation
envelope" according to section 17.1.5 of Hans von Storch and Francis W. Zwiers. Statistical analysis in climate research. Cambridge University Press, March 2001. ISBN 978-0521012300. Doing so is more robust for oscillatory processes and always provides a larger, more conservative estimate of \(T_0\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Maximum lag used to compute the autocorrelation. </td></tr>
    <tr><td class="paramname">rho</td><td>A <a class="el" href="classar_1_1predictor.html">predictor</a> iterating over the <a class="el" href="namespacear.html#a7a5016706d3db6d6b5d8c8cf9939dcfb">autocorrelation</a>. </td></tr>
    <tr><td class="paramname">abs_rho</td><td>Use \(\left|\rho\right|\) when calculating \(T_0\)?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decorrelation time \(T_0\) assuming \(\Delta{}t=1\). </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l01125">1125</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a id="a76b11e2ec00345002c64a91c3888eb0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b11e2ec00345002c64a91c3888eb0e">&#9670;&nbsp;</a></span>decorrelation_time() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Value ar::decorrelation_time </td>
          <td>(</td>
          <td class="paramtype">const std::size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classar_1_1predictor.html">predictor</a>&lt; Value &gt;&#160;</td>
          <td class="paramname"><em>rho1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classar_1_1predictor.html">predictor</a>&lt; Value &gt;&#160;</td>
          <td class="paramname"><em>rho2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>abs_rho</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the decorrelation time for a covariance given autocorrelation details from two processes. </p>
<p>That is, compute </p><p class="formulaDsp">
\begin{align} T_0 &amp;= 1 + 2 \sum_{i=1}^{N} \left(1 - \frac{i}{N}\right) \rho_{1,i} \rho_{2,i} \end{align}
</p>
<p> following Trenberth, K. E. "Some effects of finite sample size and
persistence on meteorological statistics. Part I: Autocorrelations." Monthly Weather Review 112 (1984). <a href="http://dx.doi.org/10.1175/1520-0493(1984)112%3C2359:SEOFSS%3E2.0.CO;2">http://dx.doi.org/10.1175/1520-0493(1984)112%3C2359:SEOFSS%3E2.0.CO;2</a></p>
<p>Rather than \(\rho\), \(\left|\rho\right|\) may be used in the definition of \(T_0\) to better approximate the "decay of the correlation
envelope" according to section 17.1.5 of Hans von Storch and Francis W. Zwiers. Statistical analysis in climate research. Cambridge University Press, March 2001. ISBN 978-0521012300. Doing so is more robust for oscillatory processes and always provides a larger, more conservative estimate of \(T_0\).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>Maximum lag used to compute the autocorrelation. </td></tr>
    <tr><td class="paramname">rho1</td><td>A <a class="el" href="classar_1_1predictor.html">predictor</a> iterating over the <a class="el" href="namespacear.html#a7a5016706d3db6d6b5d8c8cf9939dcfb">autocorrelation</a> for the first process. </td></tr>
    <tr><td class="paramname">rho2</td><td>A <a class="el" href="classar_1_1predictor.html">predictor</a> iterating over the <a class="el" href="namespacear.html#a7a5016706d3db6d6b5d8c8cf9939dcfb">autocorrelation</a> for the first process. </td></tr>
    <tr><td class="paramname">abs_rho</td><td>Use \(\left|\rho\right|\) when calculating \(T_0\)?</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The decorrelation time \(T_0\) assuming \(\Delta{}t=1\). </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l01176">1176</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a id="a3e0c91c44b2b3f6c6bfed77bda7dddc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e0c91c44b2b3f6c6bfed77bda7dddc8">&#9670;&nbsp;</a></span>evaluate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Result , typename Integer1 , typename Integer2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result ar::evaluate </td>
          <td>(</td>
          <td class="paramtype">Result&#160;</td>
          <td class="paramname"><em>sigma2e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer1&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer2&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate a given <a class="el" href="structar_1_1criterion.html">criterion</a> for <code>N</code> samples and model order <code>p</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sigma2e</td><td>The residual \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The model order use to compute \(sigma^2_\epsilon\)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the evaluated criterion. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l01854">1854</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a id="a14979334236bcae660b9d47b7650d148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14979334236bcae660b9d47b7650d148">&#9670;&nbsp;</a></span>evaluate_models() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer1 , typename Integer2 , class InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;InputIterator&gt;::difference_type ar::evaluate_models </td>
          <td>(</td>
          <td class="paramtype">Integer1&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer2&#160;</td>
          <td class="paramname"><em>ordfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the index of the best model from a hierarchy of candidates according to a <a class="el" href="structar_1_1criterion.html">criterion</a> given \(\sigma^2_\epsilon\) for each model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ordfirst</td><td>The model order corresponding to <code>first</code>. When \(sigma^2_\epsilon\) is produced entirely by <a class="el" href="namespacear.html#a670daa7e96d698681f914427999105fd">burg_method</a>, this should be <code>0u</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the range holding \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of input range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance from <code>first</code> to the best model.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>evaluate_models(Criterion,Integer1,Integer2,InputIterator,OutputIterator) </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l02427">2427</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a id="a8d518479a1387bcc941516059b60bbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d518479a1387bcc941516059b60bbaa">&#9670;&nbsp;</a></span>evaluate_models() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Criterion , typename Integer1 , typename Integer2 , class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;InputIterator&gt;::difference_type ar::evaluate_models </td>
          <td>(</td>
          <td class="paramtype">Integer1&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Integer2&#160;</td>
          <td class="paramname"><em>ordfirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>crit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Algorithmic helpers for autoregressive model order selection. </p>
<p>Evaluate a <a class="el" href="structar_1_1criterion.html">criterion</a> on a hierarchy of models given \(\sigma^2_\epsilon\) for each model. The index of the best model, i.e. the one with minimum criterion value, is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td>Sample count used to compute \(\sigma^2_\epsilon\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ordfirst</td><td>The model order corresponding to <code>first</code>. When \(\sigma^2_\epsilon\) is produced entirely by <a class="el" href="namespacear.html#a670daa7e96d698681f914427999105fd">burg_method</a> with <code>hierarchy == true</code>, this should be <code>0</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the range holding \(\sigma^2_\epsilon\) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of input range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">crit</td><td>Value assigned to each model by the criterion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The distance from <code>first</code> to the best model. An obscenely negative value is returned on error. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l02243">2243</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a id="abc8edd650a3846299d4906706c5c6554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8edd650a3846299d4906706c5c6554">&#9670;&nbsp;</a></span>negative_half_reflection_coefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueType , typename InputIterator1 , typename InputIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType ar::negative_half_reflection_coefficient </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>b_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Algorithms for autoregressive parameter estimation and manipulation. </p>
<p>Robustly compute negative one half the reflection coefficient assuming \(\vec{a}\) and \(\vec{b}\) contain real-valued backward and forward prediction error sequences, respectively. Zero is returned whenever the reflection coefficient numerator is identically zero, as otherwise constant zero signals produce undesired NaN reflection coefficients. The constant zero special case does not defeat NaN detection as any data introducing NaN into the denominator must introduce NaN into the numerator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_first</td><td>Beginning of the first input range \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_last</td><td>Exclusive end of first input range \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b_first</td><td>Beginning of the second input range \(\vec{b}\).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\(\frac{\vec{a}\cdot\vec{b}} {\vec{a}\cdot\vec{a} + \vec{b}\cdot\vec{b}}\) when that numerator is nonzero, else zero.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Wikipedia's article on <a href="">Kahan summation</a> for background on how the accumulation error is reduced in the result. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l00470">470</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a id="a60ab56a1353604713d01d7e2bfdd7d19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60ab56a1353604713d01d7e2bfdd7d19">&#9670;&nbsp;</a></span>welford_covariance_population()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputType1 , typename OutputType2 , typename OutputType3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_covariance_population </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>mean2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType3 &amp;&#160;</td>
          <td class="paramname"><em>covar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute means and the population covariance using Welford's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first1</td><td>Beginning of the first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>Exclusive end of first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first2</td><td>Beginning of the second input range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean1</td><td>Mean of the first data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean2</td><td>Mean of the second data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covar</td><td>The covariance of the two sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number data values processed within <code>[first1, last1)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l00326">326</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p class="reference">References <a class="el" href="ar_8hpp_source.html#l00271">welford_ncovariance()</a>.</p>

</div>
</div>
<a id="a6164224fd503bede95e82cd17efe9602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6164224fd503bede95e82cd17efe9602">&#9670;&nbsp;</a></span>welford_covariance_sample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputType1 , typename OutputType2 , typename OutputType3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_covariance_sample </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>mean2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType3 &amp;&#160;</td>
          <td class="paramname"><em>covar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute means and the sample covariance using Welford's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first1</td><td>Beginning of the first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>Exclusive end of first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first2</td><td>Beginning of the second input range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean1</td><td>Mean of the first data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean2</td><td>Mean of the second data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">covar</td><td>The covariance of the two sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number data values processed within <code>[first1, last1)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l00356">356</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p class="reference">References <a class="el" href="ar_8hpp_source.html#l00271">welford_ncovariance()</a>.</p>

</div>
</div>
<a id="a05f159864e36a0fe05c91d135163d8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f159864e36a0fe05c91d135163d8e6">&#9670;&nbsp;</a></span>welford_inner_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType ar::welford_inner_product </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inner product of <code>[first, last)</code> with itself using <a class="el" href="namespacear.html#a518cd63b6ed82adadabf114638cc77d6">welford_nvariance</a>. </p>
<p>Welford's algorithm is combined with the linearity of the expectation operator to compute a more expensive but also more numerically stable result than can be had using <code>std::inner_product</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>Initial value, often zero, establishing the result type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inner product of <code>[first, last)</code> with itself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l00383">383</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p class="reference">References <a class="el" href="ar_8hpp_source.html#l00178">welford_nvariance()</a>.</p>

</div>
</div>
<a id="af180d5f884ab6ea894c512750ca4d962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af180d5f884ab6ea894c512750ca4d962">&#9670;&nbsp;</a></span>welford_inner_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ValueType ar::welford_inner_product </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the inner product of <code>[first1, last1)</code> against <code>[first2, ...)</code> using <a class="el" href="namespacear.html#a2f96bcc639ebc309499cfebb379f29a1">welford_ncovariance</a>. </p>
<p>Welford's algorithm is combined with the linearity of the expectation operator to compute a more expensive but also numerically stable result than can be had using <code>std::inner_product</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first1</td><td>Beginning of the first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>Exclusive end of first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first2</td><td>Beginning of the second input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">init</td><td>Initial value, often zero, establishing the result type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inner product of <code>[first1, last1)</code> against <code>[first2, ...)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l00411">411</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p class="reference">References <a class="el" href="ar_8hpp_source.html#l00271">welford_ncovariance()</a>.</p>

</div>
</div>
<a id="a2f96bcc639ebc309499cfebb379f29a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f96bcc639ebc309499cfebb379f29a1">&#9670;&nbsp;</a></span>welford_ncovariance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputType1 , typename OutputType2 , typename OutputType3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_ncovariance </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>mean2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType3 &amp;&#160;</td>
          <td class="paramname"><em>ncovar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute means and the number of samples, N, times the population covariance using Welford's algorithm. </p>
<p>The implementation follows the covariance section of <a href="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first1</td><td>Beginning of the first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last1</td><td>Exclusive end of first input range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first2</td><td>Beginning of the second input range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean1</td><td>Mean of the first data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean2</td><td>Mean of the second data set. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ncovar</td><td>N times the covariance of the two sets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number data values processed within <code>[first1, last1)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l00271">271</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a id="a518cd63b6ed82adadabf114638cc77d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a518cd63b6ed82adadabf114638cc77d6">&#9670;&nbsp;</a></span>welford_nvariance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputType1 , typename OutputType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_nvariance </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>nvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stable, one-pass algorithms for computing variances and covariances. </p>
<p>Compute the mean and the number of samples, N, times the population variance using Welford's algorithm. The latter quantity is effectively the centered sum of squares. The algorithm is found in Knuth's TAOCP volume 2 section 4.2.2.A on page 232. The implementation follows <a href="http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance">http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>Mean of the data in <code>[first, last)</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nvar</td><td>N times the variance of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number data values processed within <code>[first, last)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l00178">178</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
<a id="ad13465e84fea5f3dfe2f816d94e1366e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13465e84fea5f3dfe2f816d94e1366e">&#9670;&nbsp;</a></span>welford_variance_population()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputType1 , typename OutputType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_variance_population </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean and population variance using Welford's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>Mean of the data in <code>[first, last)</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">var</td><td>The population variance of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N, the number data values processed within <code>[first, last)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l00217">217</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p class="reference">References <a class="el" href="ar_8hpp_source.html#l00178">welford_nvariance()</a>.</p>

</div>
</div>
<a id="a4ba403ed9017738637e7df54c8ce56f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba403ed9017738637e7df54c8ce56f6">&#9670;&nbsp;</a></span>welford_variance_sample()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputType1 , typename OutputType2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ar::welford_variance_sample </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType1 &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputType2 &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the mean and sample variance using Welford's algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>Beginning of the input data range. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>Exclusive end of the input data range. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">mean</td><td>Mean of the data in <code>[first, last)</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">var</td><td>The sample variance of the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>N, the number data values processed within <code>[first, last)</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l00241">241</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p class="reference">References <a class="el" href="ar_8hpp_source.html#l00178">welford_nvariance()</a>.</p>

</div>
</div>
<a id="a56c06d16a7b5c604987077f1f26ce793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c06d16a7b5c604987077f1f26ce793">&#9670;&nbsp;</a></span>zohar_linear_solve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator , class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ar::zohar_linear_solve </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>d_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a real-valued, symmetric Toeplitz set of linear equations in-place. </p>
<p>That is, compute </p><p class="formulaDsp">
\[ L_{n+1}^{-1} d_{n+1} \mbox{ for } L_{n+1} = \bigl(\begin{smallmatrix} 1 &amp; \tilde{a}_n \\ a_n &amp; L_n \end{smallmatrix}\bigr) \]
</p>
<p> given \(\vec{a}\) and \(\vec{d}\). The dimension of the problem is fixed by <code>n = distance(a_first, a_last)</code>. The working precision is fixed by the <code>value_type</code> of <code>d_first</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_first</td><td>Beginning of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_last</td><td>End of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_first</td><td>Beginning of the range containing \(\vec{d}\). Also the beginning of the output range to which <b><code>n+1</code></b> entries will be written. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l01422">1422</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p class="reference">References <a class="el" href="ar_8hpp_source.html#l01241">zohar_linear_solve()</a>.</p>

</div>
</div>
<a id="a7674a4a77e1bf418e8bcffe16d746d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7674a4a77e1bf418e8bcffe16d746d60">&#9670;&nbsp;</a></span>zohar_linear_solve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator , class ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ar::zohar_linear_solve </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>r_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>d_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a Toeplitz set of linear equations in-place. </p>
<p>That is, compute </p><p class="formulaDsp">
\[ L_{n+1}^{-1} d_{n+1} \mbox{ for } L_{n+1} = \bigl(\begin{smallmatrix} 1 &amp; \tilde{a}_n \\ r_n &amp; L_n \end{smallmatrix}\bigr) \]
</p>
<p> given \(\vec{a}\), \(\vec{r}\), and \(\vec{d}\). The dimension of the problem is fixed by <code>n = distance(a_first, a_last)</code>. A symmetric Toeplitz solve can be performed by having \(\vec{a}\) and \(\vec{r}\) iterate over the same data. The Hermitian case requires two buffers with \(vec{r}\) being the conjugate of \(\vec{a}\). The working precision is fixed by the <code>value_type</code> of <code>d_first</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_first</td><td>Beginning of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_last</td><td>End of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_first</td><td>Beginning of the range containing \(\vec{r}\). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_first</td><td>Beginning of the range containing \(\vec{d}\). Also the beginning of the output range to which <b><code>n+1</code></b> entries will be written. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l01389">1389</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

<p class="reference">References <a class="el" href="ar_8hpp_source.html#l01241">zohar_linear_solve()</a>.</p>

</div>
</div>
<a id="aad85e91b10f3a1b79f386d99bef753f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad85e91b10f3a1b79f386d99bef753f5">&#9670;&nbsp;</a></span>zohar_linear_solve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomAccessIterator , class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ar::zohar_linear_solve </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>a_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator&#160;</td>
          <td class="paramname"><em>r_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>d_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>s_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve a Toeplitz set of linear equations. </p>
<p>That is, find \(s_{n+1}\) satisfying </p><p class="formulaDsp">
\[ L_{n+1} s_{n+1} = d_{n+1} \mbox{ where } L_{n+1} = \bigl(\begin{smallmatrix} 1 &amp; \tilde{a}_n \\ r_n &amp; L_n \end{smallmatrix}\bigr) \]
</p>
<p> given \(\vec{a}\), \(\vec{r}\), and \(\vec{d}\). The dimension of the problem is fixed by <code>n = distance(a_first, a_last)</code>. A symmetric Toeplitz solve can be performed by having \(\vec{a}\) and \(\vec{r}\) iterate over the same data. The Hermitian case requires two buffers with \(vec{r}\) being the conjugate of \(\vec{a}\). The working precision is fixed by the <code>value_type</code> of <code>d_first</code>.</p>
<p>The algorithm is from Zohar, Shalhav. "The Solution of a Toeplitz Set of
Linear Equations." J. ACM 21 (April 1974): 272-276. <a href="http://dx.doi.org/10.1145/321812.321822">http://dx.doi.org/10.1145/321812.321822</a>. It has complexity like <code>O(2*(n+1)^2)</code>. Zohar improved upon earlier work from Page 1504 from Trench, William F. "Weighting Coefficients for the Prediction of Stationary
Time Series from the Finite Past." SIAM Journal on Applied Mathematics 15 (November 1967): 1502-1510. <a href="http://www.jstor.org/stable/2099503.See">http://www.jstor.org/stable/2099503.See</a> Bunch, James R. "Stability of Methods for Solving Toeplitz Systems of
Equations." SIAM Journal on Scientific and Statistical Computing 6 (1985): 349-364. <a href="http://dx.doi.org/10.1137/0906025">http://dx.doi.org/10.1137/0906025</a> for a discussion of the algorithm's stability characteristics.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a_first</td><td>Beginning of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a_last</td><td>End of the range containing \(\vec{a}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">r_first</td><td>Beginning of the range containing \(\vec{r}\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_first</td><td>Beginning of the range containing \(\vec{d}\) which should have <code>n+1</code> entries available. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">s_first</td><td>Beginning of the output range to which <code>n+1</code> entries will be written. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ar_8hpp_source.html#l01241">1241</a> of file <a class="el" href="ar_8hpp_source.html">ar.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
